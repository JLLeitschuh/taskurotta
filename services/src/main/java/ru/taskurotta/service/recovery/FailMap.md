# Рабочие процессы

## Старт

Смогли вызвать processService но дальше ломаемся. Клиенту сообщаем что процесс не создан,
и он его пытается создать заного. Если с customId то не сможет создать уже никогда. Это BUG. Надо чтобы положительный
отклик в processService приводил к положительному ответу клиенту. Далее наша забота довести процесс до конца.

Даже если мы все задачи выполним, сообщение от клиента к серверу сожет не дойти и он будет думать что процесс не
создан. Попытается его создать заного. Тут два варианта:

1. Будет создавать с customId. BUG: мы должны определить что у нас уже есть _такой-же_ процесс с указанным customId,
и вернуть ему Ok. Или лучше надо сказать лучше ему - уже есть такой процесс. Будет ли он отрабатывать это сообщение
или нет - его дело. Т.е. мы приходим к кодам ответа. 0 - все хорошо, 1 - уже есть такой процесс,
2 - ошибка при создании процесса (избыточен ли код? нужно ли оперировать кодами http или лучше не смешивать?).
2. Будет создавать не с customId. Тут мы ничего поделать не можем видимо. Надо предупреждать клиентов,
если они хотят чтобы был запущен только один процесс, то им необходимо их самостоятельно идентифицировать через
customId.

Как отследить то, что мы сообщили сервису процессов но не смогли довести создание процесса до конца. Варианты:

- (приоритетное пока направление из перечисленных) сделать новый статус процесс и после выполнения действий по
созданию процесса
перевести его в соответствующий
статус. Искать процессы которые не прошли всю процедуру в течении ожидаемого интервала времени по БД. Минусы: +1
запрос в базе данных сервиса процессов. Возможное сглаживание проблемы - перевести все доп задачи в дистрибутивную
таску по аналогии с обработкой результата выполнения процесса. Переводить на дистрибутивную таску судя по всему надо
в любом случае. Это в сумме положительно скажится на скорости так как работа сервисов очередей и задач не будет
предполагать дополнительную репликацию данных на владельца партиции процесса. Еще Минус: если не смогли изменить
статус процесса то можем послать задачу в очередь повторно. Чтобы этого избежать,
сервис зависимостей должен нам сообщать - дублирующий это запрос или нет. Если дублирующий,
то мы не ставим задачу. Даже если мы ранее сломались на укладке задачи в очередь,
то восстановление уже на плечах сервиса, отслеживающего время выполнения задачи. Т.е. должен сработать сеханизм
восстановления на случай если актер взял задачу, но не выполнил.
- реализация поддержки транзакций. Минусы: дорого если сами сервисы начнут выполнять камиты отмечая это в БД.
- реализация докатки процесса (чекпоинты). Сначала отмечаем в персистентной мапе что начали процесс создания. После
завершения удаляем запись. Переодически ищем те что не смогли выполнится и запускаем выполнение повторно. Чем это
отличается от дополнительного статуса процесса? Только тем что процесс не знает про эти телодвижения. Но есть и
минусы: чтобы узнать реальное состояние процесса через консоль, надо еще по чекпоинтам бегать иногда. Еще одна
серилизация всех данных в другое хранилище.
- делать отметку у процесса только если не смогли выполнить все задачи. Плюс: доп работа только когда негативный
сценарий. Минус: повторноя запись в БД сервиса процессов может не пройти

В случае если мы будем перезапускать задачи регистрации процесса когда обнаружим что они все не прошли,
то нам необходимо чтобы сервис задач и сервис зависимостей нормально воспринимали вызовы по одной и той-же задачи
повтороно на данном этапе и игнорировали это.



## Получение задачи

## Получение результата

### Обработка результата

# Recovery events

## Process

### From start to end timeout (PROCESS_START_TO_END_TIMEOUT)

## Task

### From enqueue to end timeout (TASK_ENQUEUE_TO_END_TIMEOUT)

### From poll to end timeout (TASK_POLL_TO_END_TIMEOUT)

### From last heartbeat timeout (TASK_HEARTBEAT_TIMEOUT)


