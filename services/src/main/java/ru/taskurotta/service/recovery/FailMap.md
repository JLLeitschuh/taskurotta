# Наша цель

Ломаться может везде. Мы должны быть к этому готовы и реагировать как можно быстрее.

# Наши задачи

Есть три причины по которым мы можем ломаться:
1. Внешнее окружение. Актер берет задачу и не приносит ответ.
2. Внутреннее окружение. Отсутствует связь с монгой или ораклом, проблемы с файловой системой и т.д.
3. Пытаясь восстановить процесс мы можем его сломать нарушив консистентность между сущностями процесса.

Есть еще логическая поломка процесса в результате программной ошибки. Для их исправления необходим перезапуск одного
или нескольких процессов с начала или с определенной задачи.

У нас есть следующие способы исправить ситуацию
1. В случае ошибок во внешнем или внутреннем окружении мы должны уметь эффективно восстанавливать консистентность
между сущностями процесса. Делать надо это автоматически.
2. Чтобы не сломать консистентность сущностей во время выполнения процесса или его восстановления необходимо все
чувствительные операции выполнять атомарно с проверкой состояния изменяемой сущности.
3. Надо предоставить средства для быстрого массового восстановления по команде оператора. Например после полной
потери данных или большого сбоя.
4. Надо предоставить средства для расширенного поиска (отбора процессов) по различным критериям и их перезапуска с
нуля или с определенной задачи.

# Решение для пункта 1 - сбои во внешнем и внутреннем окружении

- Для каждого типа актера вводится настройка WorkerTimeout. Перед отдачей задачи актеру у сущности Decision отмечается
время когда необходима реакция процесса восстановления. Поле recoveryTime.
- Для каждого типа процесса вводится настройка ProcessTimeout. При регистрации у сущности Process отмечается время
когда необходима реакция процесса восстановления. Поле recoveryTime.
- Для каждого типа процесса вводится настройка IdleProcessTimeout. При любом изменении сущности Graph отмечается
когда необходима реакция процесса восстановления. Поле recoveryTime.

note: При регистрации процесса мы должны сделать минимум - сохранить сущность Process и ответить положительно клиенту
 в случае успеха. Иначе мы можем сломаться дальше при регистрационных действиях, клиенту ответим ошибкой а сами не
 будем знать по какой причине процесс находится в таком неконсистентном состоянии и что с ним делать. При этом нам
 надо как можно раньше среагировать и проверить процесс что с ним все в порядке. Для этого предлагается выставлять
 ему более раннее время для проверки процессом восстановления. Например равное IdleProcessTimeout.

И так - у нас три сущности обладают метками времени. Для каждой из них мы запускаем свой процесс обработки.

## Обработка Decision

Выборка:
- Выбираем сущности Decision которые находятся в состоянии "в работе" и у которых значение recoveryTime в прошлом.

В каких случаях задача попадает под анализ:
- Отдали актеру задачу а он не сообщил о решении в указанный срок.

Наши действия:
- Атомарно перевести задачу в состояние "в очереди" с проверкой что она все еще находится в состоянии "в работе". Т.е
. не смогла например успеть завершиться за время анализа. При этом необходимо сменить ключ приема результата "pass"
чтобы не принять в будущем старый результат.
- Отправляем задачу в очередь повторно.
- Изменяем значение recoveryTime у сущности Graph.
- Увеличиваем общий счетчик workTimeoutCounter. (на счетчики реагирует мониторинг)
- Увеличиваем счетчик workTimeoutCounter для данного актера.

Исключения (надо план действий на каждое):
1. На момент анализа невозможно получить описание задачи из за ошибки доступа к БД.
2. Отсутствует описание задачи в БД (сущности Task). Невозможно ее поставить повторно в очередь.
Действие: Процесс помечается как неконсистентный или автоматически перезапускается?

## Обработка Graph

Выборка:
- Выбираем сущности Graph у которых recoveryTime в прошлом.

note: у Graph сейчас нет состояния. Надо его либо вводить (+1 индекс в БД) либо выставлять значение recoveryTime в
Long.MAX_VALUE (ухудшение работы индекса?)

В каких случаях Graph попадает под анализ - долго нет изменений в процессе:
1. Сервер суслика был выключен, задачи не раздавались
2. Нет актеров необходимых для работы процесса
3. Актеры не справляются с количеством задач в очереди
4. Приняли решение по задаче но не смогли отправить на анализ в Graph
5. Получили результат анализа выполненной задачи в Graph а отправить задачу в очередь не смогли.
6. При восстановлении изменили состояние задачи на "в очереди" а в очередь положить не смогли.
7. Процесс зарегистрировали, создали граф, а дальше не смогли зарегистрировать стартовую задачу и положить ее в очередь.

Решение по каждому пункту. После действий по каждому решению и сущности Graph изменяется значение recoveryTime:



## Обработка Process

- Получили все задачи но не смогли выставить состояние "завершен".

# Решение для пункта 2 - обеспечение консистентности между сущностями процесса
# Решение для пункта 3 - массовое восстановление данных
# Решение для пункта 4 - интеллектуальный поиск и восстановление по шаблонам
