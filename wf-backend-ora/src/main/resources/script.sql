CREATE TABLE QB$QUEUE_NAMES
(
  QUEUE_ID   NUMBER        NOT NULL,
  QUEUE_NAME VARCHAR2(256) NOT NULL,
  PRIMARY KEY (QUEUE_ID)
);

CREATE UNIQUE INDEX QB$UNIQUE_NAME
ON QB$QUEUE_NAMES (QUEUE_NAME ASC);

CREATE SEQUENCE QB$SEQUENCE MINVALUE 1 MAXVALUE 9999999999999999999999999999 INCREMENT BY 1 START WITH 1 CACHE 20 NOORDER NOCYCLE;
CREATE SEQUENCE QB$CHECKPOINT_SEQUENCE MINVALUE 1 MAXVALUE 9999999999999999999999999999 INCREMENT BY 1 START WITH 1 CACHE 20 NOORDER NOCYCLE;


CREATE TABLE TASK (
  UUID       VARCHAR2(36) NOT NULL,
  JSON_VALUE CLOB         NULL,
  PRIMARY KEY (UUID)
)
NOCOMPRESS
;

CREATE TABLE DECISION (
  TASK_ID       VARCHAR2(36) NOT NULL,
  PROCESS_ID    VARCHAR2(36) NOT NULL,
  DECISION_JSON CLOB         NOT NULL,
  PRIMARY KEY (TASK_ID, PROCESS_ID)
)
NOCOMPRESS
;


CREATE TABLE TR_CHECKPOINTS (
  ID              NUMBER        NOT NULL,
  ENTITY_ID       VARCHAR2(36)  NOT NULL,
  ENTITY_TYPE     VARCHAR2(255) NOT NULL,
  TYPE_TIMEOUT    VARCHAR2(36)  NOT NULL,
  CHECKPOINT_TIME NUMBER        NOT NULL,
  PRIMARY KEY (ID)
)
NOCOMPRESS
;

ALTER TABLE DECISION ADD CONSTRAINT TASK_DECISION FOREIGN KEY (TASK_ID) REFERENCES TASK (UUID);

CREATE TABLE GRAPH (
  ID       VARCHAR2(36) NOT NULL,
  VERSION  NUMBER       NOT NULL,
  JSON_STR CLOB         NOT NULL,
  PRIMARY KEY (id)
)
NOCOMPRESS
;

CREATE TABLE GRAPH_DECISION (
  FINISHED_TASK_ID  VARCHAR2(36) NOT NULL,
  READY_ITEMS       CLOB         NOT NULL,
  MODIFICATION_JSON CLOB         NOT NULL,
  PRIMARY KEY (FINISHED_TASK_ID)
)
NOCOMPRESS
;

CREATE OR REPLACE TRIGGER TR_CHECKPOINTS_BI
BEFORE INSERT
ON TR_CHECKPOINTS
FOR EACH ROW
  BEGIN
    IF :NEW.id IS NULL
    THEN
      SELECT
        QB$CHECKPOINT_SEQUENCE.NEXTVAL
      INTO :NEW.id
      FROM DUAL;
    END IF;
  END;
/

CREATE TABLE process (
  process_id    VARCHAR2(36)  NOT NULL,
  start_task_id VARCHAR2(36)  NOT NULL,
  custom_id     VARCHAR2(256) NULL,
  start_time    NUMBER        NOT NULL,
  end_time      NUMBER        NULL,
  state         NUMBER        NOT NULL,
  return_value  CLOB          NULL,
  PRIMARY KEY (process_id)
)
NOCOMPRESS
;

ALTER TABLE process ADD CONSTRAINT custom_id_uq UNIQUE (custom_id);

DELETE FROM DECISION;
DELETE FROM TASK;

ALTER TABLE TASK
ADD ( NUMBER_OF_ATTEMPTS NUMBER NOT NULL  )
ADD ( ACTOR_ID VARCHAR2(256) NOT NULL  );

ALTER TABLE DECISION
ADD ( IS_ERROR NUMBER(1) NOT NULL  )
ADD ( DECISION_DATE NUMBER NOT NULL  );

CREATE OR REPLACE
PROCEDURE ADD_DECISION(P_TASK_ID  IN VARCHAR2, P_PROCESS_ID IN VARCHAR2, P_DECISION_JSON IN CLOB,
                       P_IS_ERROR IN NUMBER, P_DECISION_DATE IN NUMBER)
AS
  BEGIN
    MERGE INTO DECISION D
    USING
      (SELECT
         P_TASK_ID       AS TASK_ID,
         P_DECISION_JSON AS DECISION_JSON,
         P_IS_ERROR      AS IS_ERROR,
         P_DECISION_DATE AS DECISION_DATE,
         P_PROCESS_ID    AS PROCESS_ID
       FROM DUAL) S
    ON (D.TASK_ID = S.TASK_ID)
    WHEN MATCHED THEN
    UPDATE SET D.DECISION_JSON = S.DECISION_JSON,
      D.IS_ERROR = S.IS_ERROR,
      D.DECISION_DATE= S.DECISION_DATE
    WHEN NOT MATCHED THEN
    INSERT (TASK_ID, PROCESS_ID, DECISION_JSON, IS_ERROR, DECISION_DATE)
    VALUES (S.TASK_ID, S.PROCESS_ID, S.DECISION_JSON, S.IS_ERROR, S.DECISION_DATE);
  END;
/

CREATE OR REPLACE
PROCEDURE add_graph_decision(P_FINISHED_TASK_ID IN VARCHAR2, P_READY_ITEMS IN CLOB, P_MODIFICATION_JSON IN CLOB)
AS
  BEGIN
    MERGE INTO GRAPH_DECISION D
    USING
      (SELECT
         P_FINISHED_TASK_ID  AS FINISHED_TASK_ID,
         P_READY_ITEMS       AS READY_ITEMS,
         P_MODIFICATION_JSON AS MODIFICATION_JSON
       FROM DUAL) S
    ON (D.FINISHED_TASK_ID = S.FINISHED_TASK_ID)
    WHEN MATCHED THEN
    UPDATE SET D.READY_ITEMS = S.READY_ITEMS,
      D.MODIFICATION_JSON= S.MODIFICATION_JSON
    WHEN NOT MATCHED THEN
    INSERT (FINISHED_TASK_ID, READY_ITEMS, MODIFICATION_JSON)
    VALUES (S.FINISHED_TASK_ID, S.READY_ITEMS, S.MODIFICATION_JSON);
  END;
/