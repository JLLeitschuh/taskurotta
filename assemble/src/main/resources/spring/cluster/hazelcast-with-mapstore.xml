<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:hz="http://www.hazelcast.com/schema/spring"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
            http://www.hazelcast.com/schema/spring http://www.hazelcast.com/schema/spring/hazelcast-spring-3.1.xsd">


    <hz:hazelcast id="hzInstance">
        <hz:config>
            <hz:management-center enabled="${hz.mancenter.enabled}" url="${hz.mancenter.url}"/>

            <hz:properties>
                <hz:property name="hazelcast.logging.type">${hz.logging.type}</hz:property>
                <hz:property name="hazelcast.jmx">${hz.jmx}</hz:property>
                <hz:property name="hazelcast.jmx.detailed">${hz.jmx.detailed}</hz:property>
            </hz:properties>

            <hz:network port="${hz.port}" port-auto-increment="true">
                <hz:join>
                    <hz:multicast enabled="false"/>
                    <hz:tcp-ip enabled="true">
                        <hz:members>${hz.nodes}</hz:members>
                    </hz:tcp-ip>
                </hz:join>
            </hz:network>

            <hz:executor-service name="${hz.executor-service.decisions.service-name}" pool-size="${hz.executor-service.decisions.pool-size}"/>

            <hz:map name="${hz.map.task.name}" backup-count="0" time-to-live-seconds="0" eviction-policy="LRU"
                    max-idle-seconds="0"
                    max-size="${hz.map.task.memory.max-size}" eviction-percentage="25"
                    max-size-policy="USED_HEAP_PERCENTAGE">
                <hz:map-store enabled="true" write-delay-seconds="0" implementation="mapStore"/>
            </hz:map>

            <hz:map name="${hz.map.decision.name}" backup-count="0" time-to-live-seconds="0" eviction-policy="LRU"
                    max-idle-seconds="0"
                    max-size="${hz.map.decision.memory.max-size}" eviction-percentage="25"
                    max-size-policy="USED_HEAP_PERCENTAGE">
                <hz:map-store enabled="true" write-delay-seconds="0" implementation="mapStore"/>
            </hz:map>

            <hz:map name="${hz.map.graph.name}" backup-count="0" time-to-live-seconds="0" eviction-policy="LRU"
                    max-idle-seconds="0"
                    max-size="${hz.map.graph.memory.max-size}" eviction-percentage="25"
                    max-size-policy="USED_HEAP_PERCENTAGE">
                <hz:map-store enabled="true" write-delay-seconds="0" implementation="mapStore"/>
            </hz:map>

            <hz:map name="${hz.map.graph-decision.name}" backup-count="0" time-to-live-seconds="0" eviction-policy="LRU"
                    max-idle-seconds="0"
                    max-size="${hz.map.graph-decision.memory.max-size}" eviction-percentage="25"
                    max-size-policy="USED_HEAP_PERCENTAGE">
                <hz:map-store enabled="true" write-delay-seconds="0" implementation="mapStore"/>
            </hz:map>

            <hz:map name="${hz.map.process.name}" backup-count="0" time-to-live-seconds="0" eviction-policy="LRU"
                    max-idle-seconds="0"
                    max-size="${hz.map.process.memory.max-size}" eviction-percentage="25"
                    max-size-policy="USED_HEAP_PERCENTAGE">
                <hz:map-store enabled="true" write-delay-seconds="0" implementation="mapStore"/>
            </hz:map>

            <hz:map name="${hz.map.broken-process.name}" backup-count="0" time-to-live-seconds="0" eviction-policy="LRU"
                    max-idle-seconds="0"
                    max-size="1000" eviction-percentage="25" max-size-policy="PER_NODE">
                <hz:map-store enabled="true" write-delay-seconds="0" implementation="mapStore"/>
            </hz:map>

            <hz:map name="${hz.map.actor-preferences.name}" backup-count="0">
                <hz:map-store enabled="true" write-delay-seconds="0" implementation="mapStore"/>
            </hz:map>

            <hz:serialization>
                <hz:serializers>
                    <hz:serializer type-class="ru.taskurotta.transport.model.TaskConfigContainer"
                                   class-name="ru.taskurotta.service.hz.serialization.TaskConfigContainerStreamSerializer"/>
                    <hz:serializer type-class="ru.taskurotta.transport.model.ArgContainer"
                                   class-name="ru.taskurotta.service.hz.serialization.ArgContainerStreamSerializer"/>
                    <hz:serializer type-class="ru.taskurotta.service.console.model.BrokenProcess"
                                   class-name="ru.taskurotta.service.hz.serialization.BrokenProcessStreamSerializer"/>
                    <hz:serializer type-class="ru.taskurotta.transport.model.DecisionContainer"
                                   class-name="ru.taskurotta.service.hz.serialization.DecisionContainerStreamSerializer"/>
                    <hz:serializer type-class="ru.taskurotta.service.hz.dependency.HzGraphDao.DecisionRow"
                                   class-name="ru.taskurotta.service.hz.serialization.DecisionRowStreamSerializer"/>
                    <hz:serializer type-class="ru.taskurotta.transport.model.ErrorContainer"
                                   class-name="ru.taskurotta.service.hz.serialization.ErrorContainerStreamSerializer"/>
                    <hz:serializer type-class="ru.taskurotta.service.dependency.links.Graph"
                                   class-name="ru.taskurotta.service.hz.serialization.GraphStreamSerializer"/>
                    <hz:serializer type-class="ru.taskurotta.service.console.model.Process"
                                   class-name="ru.taskurotta.service.hz.serialization.ProcessStreamSerializer"/>
                    <hz:serializer type-class="ru.taskurotta.transport.model.TaskContainer"
                                   class-name="ru.taskurotta.service.hz.serialization.TaskContainerStreamSerializer"/>
                    <hz:serializer type-class="ru.taskurotta.service.hz.TaskKey"
                                   class-name="ru.taskurotta.service.hz.serialization.TaskKeyStreamSerializer"/>
                    <hz:serializer type-class="ru.taskurotta.transport.model.TaskOptionsContainer"
                                   class-name="ru.taskurotta.service.hz.serialization.TaskOptionsContainerSerializer"/>
                    <hz:serializer type-class="java.util.UUID"
                                   class-name="ru.taskurotta.service.hz.serialization.UUIDStreamSerializer"/>
                    <hz:serializer type-class="ru.taskurotta.service.queue.TaskQueueItem"
                                   class-name="ru.taskurotta.service.hz.serialization.TaskQueueItemSteamSerializer"/>
                    <hz:serializer type-class="ru.taskurotta.hazelcast.queue.delay.impl.StorageItem"
                                   class-name="ru.taskurotta.service.hz.serialization.StorageItemStreamSerializer"/>
                    <hz:serializer type-class="ru.taskurotta.service.recovery.RecoveryOperation"
                                   class-name="ru.taskurotta.service.hz.serialization.RecoveryOperationStreamSerializer"/>
                    <hz:serializer type-class="ru.taskurotta.service.config.model.ActorPreferences"
                                   class-name="ru.taskurotta.service.hz.serialization.ActorPreferencesStreamSerializer"/>
                    <hz:serializer type-class="ru.taskurotta.service.hz.server.HazelcastTaskServer.ProcessDecisionUnitOfWork"
                                   class-name="ru.taskurotta.service.hz.serialization.ProcessDecisionUnitOfWorkStreamSerializer"/>
                </hz:serializers>
            </hz:serialization>
        </hz:config>
    </hz:hazelcast>

</beans>