CREATE TABLE QB$QUEUE_NAMES
(
  QUEUE_ID   NUMBER        NOT NULL,
  QUEUE_NAME VARCHAR2(256) NOT NULL,
  PRIMARY KEY (QUEUE_ID)
);

CREATE UNIQUE INDEX QB$UNIQUE_NAME
ON QB$QUEUE_NAMES (QUEUE_NAME ASC);

CREATE SEQUENCE QB$SEQUENCE MINVALUE 1 MAXVALUE 9999999999999999999999999999 INCREMENT BY 1 START WITH 1 CACHE 20 NOORDER NOCYCLE;
CREATE SEQUENCE QB$CHECKPOINT_SEQUENCE MINVALUE 1 MAXVALUE 9999999999999999999999999999 INCREMENT BY 1 START WITH 1 CACHE 20 NOORDER NOCYCLE;


CREATE TABLE TASK (
  UUID        VARCHAR2(36) NOT NULL,
  PROCESS_ID  VARCHAR2(36) NOT NULL,
  JSON_VALUE  CLOB         NULL,
  PRIMARY KEY (UUID)
)
NOCOMPRESS
;
CREATE INDEX TASK_IDX_PROCESS ON TASK(PROCESS_ID);

CREATE TABLE DECISION (
  TASK_ID       VARCHAR2(36) NOT NULL,
  PROCESS_ID    VARCHAR2(36) NOT NULL,
  DECISION_JSON CLOB         NOT NULL,
  PRIMARY KEY (TASK_ID, PROCESS_ID)
)
NOCOMPRESS
;


CREATE TABLE TR_CHECKPOINTS (
  ID              NUMBER        NOT NULL,
  TASK_ID         VARCHAR2(36)  NOT NULL,
  PROCESS_ID      VARCHAR2(36)  NOT NULL,
  ACTOR_ID        VARCHAR2(255 char) NOT NULL,
  TYPE_TIMEOUT    VARCHAR2(36)  NOT NULL,
  CHECKPOINT_TIME NUMBER        NOT NULL,
  PRIMARY KEY (ID)
)
NOCOMPRESS
;

ALTER TABLE DECISION ADD CONSTRAINT TASK_DECISION FOREIGN KEY (TASK_ID) REFERENCES TASK (UUID);

CREATE TABLE GRAPH (
  ID       VARCHAR2(36) NOT NULL,
  VERSION  NUMBER       NOT NULL,
  JSON_STR CLOB         NOT NULL,
  PRIMARY KEY (id)
)
NOCOMPRESS
;

CREATE TABLE GRAPH_DECISION (
  FINISHED_TASK_ID  VARCHAR2(36) NOT NULL,
  READY_ITEMS       CLOB         NOT NULL,
  MODIFICATION_JSON CLOB         NOT NULL,
  PRIMARY KEY (FINISHED_TASK_ID)
)
NOCOMPRESS
;

CREATE OR REPLACE TRIGGER TR_CHECKPOINTS_BI
BEFORE INSERT
ON TR_CHECKPOINTS
FOR EACH ROW
  BEGIN
    IF :NEW.id IS NULL
    THEN
      SELECT
        QB$CHECKPOINT_SEQUENCE.NEXTVAL
      INTO :NEW.id
      FROM DUAL;
    END IF;
  END;
/

CREATE TABLE process (
  process_id    VARCHAR2(36)  NOT NULL,
  start_task_id VARCHAR2(36)  NOT NULL,
  custom_id     VARCHAR2(256) NULL,
  start_time    NUMBER        NOT NULL,
  end_time      NUMBER        NULL,
  state         NUMBER        NOT NULL,
  return_value  CLOB          NULL,
  PRIMARY KEY (process_id)
)
NOCOMPRESS
;

ALTER TABLE process ADD CONSTRAINT custom_id_uq UNIQUE (custom_id);

DELETE FROM DECISION;
DELETE FROM TASK;

ALTER TABLE TASK
ADD ( NUMBER_OF_ATTEMPTS NUMBER NOT NULL  )
ADD ( ACTOR_ID VARCHAR2(256) NOT NULL  );

ALTER TABLE DECISION
ADD ( IS_ERROR NUMBER(1) NOT NULL  )
ADD ( DECISION_DATE NUMBER NOT NULL  );

CREATE OR REPLACE
PROCEDURE ADD_DECISION(
  P_TASK_ID       IN VARCHAR2,
  P_PROCESS_ID    IN VARCHAR2,
  P_DECISION_JSON IN CLOB,
  P_IS_ERROR      IN NUMBER,
  P_DECISION_DATE IN NUMBER)
AS
  BEGIN
    UPDATE DECISION
    SET DECISION_JSON = P_DECISION_JSON,
      IS_ERROR        = P_IS_ERROR,
      DECISION_DATE   = P_DECISION_DATE
    WHERE task_id = P_TASK_ID;
    IF (sql%rowcount = 0)
    THEN
      INSERT
      INTO DECISION
      (
        TASK_ID,
        PROCESS_ID,
        DECISION_JSON,
        IS_ERROR,
        DECISION_DATE
      )
        VALUES
        (
          P_TASK_ID,
          P_PROCESS_ID,
          P_DECISION_JSON,
          P_IS_ERROR,
          P_DECISION_DATE
        );
    END IF;
  END;
/

CREATE OR REPLACE
PROCEDURE add_graph_decision(P_FINISHED_TASK_ID IN VARCHAR2, P_READY_ITEMS IN CLOB, P_MODIFICATION_JSON IN CLOB)
AS
  BEGIN
    UPDATE GRAPH_DECISION D
    SET D.READY_ITEMS = P_READY_ITEMS,
      D.MODIFICATION_JSON= P_MODIFICATION_JSON
    WHERE FINISHED_TASK_ID = P_FINISHED_TASK_ID;
    IF (sql%rowcount = 0)
    THEN
      INSERT INTO GRAPH_DECISION (FINISHED_TASK_ID, READY_ITEMS, MODIFICATION_JSON)
        VALUES (P_FINISHED_TASK_ID, P_READY_ITEMS, P_MODIFICATION_JSON);

    END IF;

  END;
/

ALTER TABLE TASK
ADD ( START_TIME TIMESTAMP NULL  );

ALTER TABLE QB$QUEUE_NAMES
ADD ( QUEUE_TABLE_NAME VARCHAR2(256) NULL);


ALTER TABLE PROCESS
ADD ( START_JSON CLOB NULL  ) ;


CREATE TABLE TSK_SCHEDULED
(
  ID                    NUMBER                    NOT NULL,
  NAME                  VARCHAR2(256 char)        NOT NULL,
  CRON                  VARCHAR2(256 char)        NOT NULL,
  STATUS                NUMBER                    NOT NULL,
  JSON                  VARCHAR2(2000 char)       NOT NULL,
  CREATED               TIMESTAMP,
  QUEUE_LIMIT           NUMBER,
  ERR_COUNT             NUMBER,
  LAST_ERR_MESSAGE      VARCHAR2(2000 char),
  PRIMARY KEY (ID)
);

CREATE SEQUENCE SEQ_TSK_SCHEDULED MINVALUE 1 MAXVALUE 9999999999999999999999999999 INCREMENT BY 1 START WITH 1 CACHE 20 NOORDER NOCYCLE;

CREATE OR REPLACE TRIGGER TSK_SCHEDULED_BI
BEFORE INSERT
ON TSK_SCHEDULED
FOR EACH ROW
  BEGIN
    IF :NEW.id IS NULL
    THEN
      SELECT
        SEQ_TSK_SCHEDULED.NEXTVAL
      INTO :NEW.id
      FROM DUAL;
    END IF;
  END;
/

CREATE TABLE TSK_BROKEN_PROCESSES (
    ID                NUMBER NOT NULL PRIMARY KEY,
    PROCESS_ID        VARCHAR2(50 char) NOT NULL,
    START_ACTOR_ID    VARCHAR2(500 char) NOT NULL,
    BROKEN_ACTOR_ID   VARCHAR2(500 char) NOT NULL,
    CREATION_DATE     TIMESTAMP(6) NOT NULL,
    TIME              NUMBER NOT NULL,
    ERROR_MESSAGE     VARCHAR2(500 char),
    ERROR_CLASS_NAME  VARCHAR2(500 char),
    STACK_TRACE       CLOB
);

COMMENT ON COLUMN TSK_BROKEN_PROCESSES.PROCESS_ID IS 'Broken process GUID';
COMMENT ON COLUMN TSK_BROKEN_PROCESSES.START_ACTOR_ID IS 'Actor ID of process starter actor';
COMMENT ON COLUMN TSK_BROKEN_PROCESSES.BROKEN_ACTOR_ID IS 'Actor ID of process stop causing actor';
COMMENT ON COLUMN TSK_BROKEN_PROCESSES.CREATION_DATE IS 'Row creation date';
COMMENT ON COLUMN TSK_BROKEN_PROCESSES.TIME IS 'Long representation of a failing time';
COMMENT ON COLUMN TSK_BROKEN_PROCESSES.ERROR_MESSAGE IS 'Message of the occured actor exception';
COMMENT ON COLUMN TSK_BROKEN_PROCESSES.ERROR_CLASS_NAME IS 'Full class name for the actor exception';
COMMENT ON COLUMN TSK_BROKEN_PROCESSES.STACK_TRACE IS 'Full stack trace of the exception got from actor';

CREATE SEQUENCE  SEQ_TSK_BROKEN_PROCESSES MINVALUE 1 MAXVALUE 9999999999999999999999999999 INCREMENT BY 1 START WITH 1 CACHE 20 NOORDER NOCYCLE;

CREATE OR REPLACE TRIGGER TSK_BROKEN_PROCESSES_BI
BEFORE INSERT
ON TSK_BROKEN_PROCESSES
FOR EACH ROW
  BEGIN
    IF :NEW.id IS NULL
    THEN
      SELECT
        SEQ_TSK_BROKEN_PROCESSES.NEXTVAL
      INTO :NEW.id
      FROM DUAL;
    END IF;
  END;
/

exit;

CREATE INDEX TSK_BROKEN_PROCESSES_IP ON TSK_BROKEN_PROCESSES(START_ACTOR_ID);
CREATE INDEX TSK_BROKEN_PROCESSES_IA ON TSK_BROKEN_PROCESSES(BROKEN_ACTOR_ID);
CREATE INDEX TSK_BROKEN_PROCESSES_IE ON TSK_BROKEN_PROCESSES(ERROR_CLASS_NAME);

CREATE INDEX TSK_BROKEN_PROCESSES_ITIME ON TSK_BROKEN_PROCESSES(TIME);
